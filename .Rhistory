fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, cate = TRUE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE  = TRUE)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE  = TRUE)
plot(fit$cate)
summary(cate)
summary(fit$cate)
library(MLCM)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE  = TRUE)
plot(fit$cate)
text(fit$cate)
library(MLCM)
library(MLCM)
fit$cate$splits
fit$cate$where
class(fit$cate$where)
unique(fit$cate$where)
which(fit$cate$where == 2)
which(fit$cate$where == 5)
fit$cate$frame
pred <- predict(fit$cate, type = "vector")
View(data.frame(pred = pred, fit$where))
View(data.frame(pred = pred, fit$cate$where))
fit$cate
predict(fit$cate, type = "node")
predict(fit$cate, type = "class")
predict(fit$cate, type = "matrix")
predict(fit$cate, type = "vector")
pred[which(fit$cate$where == 14)]
mean(pred[which(fit$cate$where == 14)])
mean(pred[which(fit$cate$where == 5)])
mean(pred[which(fit$cate$where == 7)])
mean(pred[which(fit$cate$where == 6)])
pred[which(fit$cate$where == 6)]
which(fit$cate$where == 6)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
node.inf <- mapply(terminal.nodes, FUN = function(x){y <- effect[which(terminal == x)];
boot.dist <- matrix(sample(y, size = nboot*length(y), replace = TRUE),
nrow = nboot, ncol = length(y));
mean.cate <- colMeans(boot.dist);
var.cate <- var(mean.cate);
conf.cate <- quantile(mean.cate, probs = c(0.025, 0.975));
c(var.cate = var.cate, cate.lower = conf.cate[1], cate.upper = conf.cate[2])},
SIMPLIFY = TRUE)
node.inf <- mapply(terminal.nodes, FUN = function(x){y <- effect[which(terminal.nodes == x)];
boot.dist <- matrix(sample(y, size = nboot*length(y), replace = TRUE),
nrow = nboot, ncol = length(y));
mean.cate <- colMeans(boot.dist);
var.cate <- var(mean.cate);
conf.cate <- quantile(mean.cate, probs = c(0.025, 0.975));
c(var.cate = var.cate, cate.lower = conf.cate[1], cate.upper = conf.cate[2])},
SIMPLIFY = TRUE)
node.inf <- mapply(terminal.nodes, FUN = function(x){y <- effect[which(terminal.nodes == x)];
boot.dist <- matrix(sample(y, size = 1000*length(y), replace = TRUE),
nrow = nboot, ncol = length(y));
mean.cate <- colMeans(boot.dist);
var.cate <- var(mean.cate);
conf.cate <- quantile(mean.cate, probs = c(0.025, 0.975));
c(var.cate = var.cate, cate.lower = conf.cate[1], cate.upper = conf.cate[2])},
SIMPLIFY = TRUE)
node.inf <- mapply(terminal.nodes, FUN = function(x){y <- effect[which(terminal.nodes == x)];
boot.dist <- matrix(sample(y, size = 1000*length(y), replace = TRUE),
nrow = 1000, ncol = length(y));
mean.cate <- colMeans(boot.dist);
var.cate <- var(mean.cate);
conf.cate <- quantile(mean.cate, probs = c(0.025, 0.975));
c(var.cate = var.cate, cate.lower = conf.cate[1], cate.upper = conf.cate[2])},
SIMPLIFY = TRUE)
View(node.inf)
terminal.nodes
which(terminal.nodes == 5)
effect[which(terminal.nodes == 5)]
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
fit$cate.inf
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
node.inf <- mapply(x, FUN = function(x){y <- effect[which(terminal.nodes == x)];
boot.dist <- matrix(sample(y, size = nboot*length(y), replace = TRUE),
nrow = nboot, ncol = length(y));
mean.cate <- colMeans(boot.dist);
var.cate <- var(mean.cate);
conf.cate <- quantile(mean.cate, probs = c(0.025, 0.975));
c(cate = mean(y), var.cate = var.cate, cate.lower = conf.cate[1], cate.upper = conf.cate[2])},
SIMPLIFY = TRUE)
View(node.inf)
View(node.inf)
cate
summary(cate)
x
node.inf <- mapply(x, FUN = function(x){y <- effect[which(terminal.nodes == x)];
boot.dist <- matrix(sample(y, size = nboot*length(y), replace = TRUE),
nrow = nboot, ncol = length(y));
mean.cate <- colMeans(boot.dist);
var.cate <- var(mean.cate);
conf.cate <- quantile(mean.cate, probs = c(0.025, 0.975));
c(cate = mean(y), var.cate = var.cate, cate.lower = as.numeric(conf.cate[1]), cate.upper = conf.cate[2])},
SIMPLIFY = TRUE)
View(node.inf)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
fit$cate.inf
class(fit$cate)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
y <- effect[which(terminal.nodes == x)]
y <- effect[which(terminal.nodes == x[1])]
boot.dist <- matrix(sample(y, size = nboot*length(y), replace = TRUE),
nrow = nboot, ncol = length(y))
View(boot.dist)
var(rowMeans(boot.distrib))
var(rowMeans(boot.dist))
quantile(rowMeans(boot.dist), probs = c(0.025, 0.975))
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 1000, CATE = TRUE)
library(CAST)
library(bcaboot)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 1000, CATE = TRUE)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 1000, CATE = TRUE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "bca", nboot = 1000, CATE = TRUE)
out2 <- bcajack2(B = Blist, alpha = alpha)
out2$lims
conf.ate <- out2$lims[c(1,3),"bca"]
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "bca", nboot = 100, CATE = TRUE)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "bca", nboot = 100, CATE = TRUE)
library8rpart
library(rpart)
library(MLCM)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "block", nboot = 100, CATE = TRUE)
fit$ate
data <- read.csv("data_ex.csv")
View(data)
rm(data)
load("~/GitHub/MLCM/data/data.rda")
View(data)
data <- data[,-1]
usethis::use_data(data)
usethis::use_data(data, overwrite = TRUE)
data <- read.csv("data_ex.csv")
data <- data[,-1]
View(data)
colnames(data) <- gsub(colnames(data), pattern = "dat.", replacement = "")
data <- data[,-16]
usethis::use_data(data, overwrite = TRUE)
library(MLCM)
View(data)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
library(CAST)
library(rpart)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
fit$ate
fit$best_method
View(data)
data <- data[data$ID <= 100, ]
dim(data)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
data <- data[data$ID <= 50, ]
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = TRUE)
warnings()
library(MLCM)
dim(data)
data <- read.csv("data_ex.csv")
View(data)
data <- data[,-1]
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = FALSE)
library(MLCM)
library(CAST)
library(rpart)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = FALSE)
datanew <- data[data$ID <= 50,]
fit <- MLCM(data = datanew, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 10, CATE = FALSE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 5, CATE = FALSE)
View(data)
datanew <- data[data$ID <= 70,]
fit <- MLCM(data = datanew, y = "Y", timevar = "year", id = "ID", post_period = 2020, inf_type = "classic", nboot = 5, CATE = FALSE)
usethis::use_data(data, overwrite = TRUE)
library(MLCM)
install.packages("RTools")
sessionInfo()
PanelCrossValidation <- function(data, int_date, pcv_block = 1, metric = "RMSE", trControl = NULL, ML_methods = NULL){
}
PanelCrossValidation <- function(data, int_date, pcv_block = 1, metric = "RMSE", trControl = NULL, ML_methods = NULL){
### Parameter checks
if(!any(class(data) %in% "PanelMLCM")) stop("Invalid class in the PanelCrossValidation function, something is wrong with as.PanelMLCM")
if(!(int_date %in% data[, "Time"])) stop("int_date must be contained in timevar")
if(length(unique(data[, "Time"])) - 2 - pcv_block < 1) stop("Panel cross validation must be performed in at least one time period")
if(pcv_block <= 0) stop("The number of 'pcv_block' time periods for panel cross validation must be at least 1")
if(!metric %in% c("RMSE", "Rsquared")) stop("Metric not allowed, check documentation")
if(is.list(ML_methods)){if(any(sapply(ML_methods, FUN = length) != 2)) stop("'ML_methods' must be a list of methods, each of length 2")}
if(is.list(ML_methods)){
if(any(sapply(ML_methods, FUN = function(x)(any(!names(x) %in% c("method", "tuneGrid")))))) stop("Each method in 'ML_methods' must be a named list, check documentation")}
### STEP 1. The CAST package is used to generate separate testing sets for each year
Tt <- length(unique(data[, "Time"]))
int_date <- int_date
indices <- CreateSpacetimeFolds(data, timevar = "Time", k = Tt) # cambiare qui
trainx <- lapply(pcv_block:(Tt-2), FUN = function(x) unlist(indices$indexOut[1:x]))
testx <- lapply(pcv_block:(Tt-2), FUN = function(x) unlist(indices$indexOut[[x+1]]))
### STEP 2. Set control function by specifying the training and testing folds that caret will use
###         for cross-validation and tuning of the hyperparameters (i.e., the combination of folds defined above)
if(is.null(trControl)){
ctrl <- trainControl(index = trainx, indexOut = testx)
} else {
ctrl <- trControl # da capire come fare i param checks
}
### STEP 3.  Tune the hyperparameters of each of the ML algorithms via temporal cross-validation
if(is.null(ML_methods)){
# STOCHASTIC GRADIENT BOOSTING
gbmGrid <-  expand.grid(interaction.depth = c(1, 2, 3),
n.trees=c(500, 1000, 1500, 2000),
shrinkage = seq(0.01, 0.1, by = 0.01),
n.minobsinnode = c(10,20))
set.seed(1)
bo <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "gbm",
metric = metric,
trControl = ctrl,
tuneGrid = gbmGrid,
verbose = FALSE)
# RANDOM FOREST
set.seed(1)
rf <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "rf",
metric = metric,
search = "grid",
trControl = ctrl,
tuneGrid = expand.grid(mtry = (2:(ncol(data)-3))),
ntree=500)
# LASSO
lasso <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "lasso",
metric = metric,
trControl = ctrl,
tuneGrid = expand.grid(fraction = seq(0.1, 0.9, by = 0.1)),
preProc=c("center", "scale"))
# PLS
pls <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "pls",
metric = metric,
trControl = ctrl,
tuneGrid = expand.grid(ncomp = c(1:10)),
preProc=c("center", "scale"))
# Storing results in a list
m_list <- list(bo = bo, rf = rf, lasso = lasso, pls = pls)
} else {
m_list <- lapply(ML_methods, FUN = function(x){train(Y ~.,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = x$method,
metric = metric,
trControl = ctrl,
tuneGrid = x$tuneGrid)})
}
### STEP 4. Selecting the "best" ML algorithm based on the provided performance metric
rmse_min <- sapply(m_list, FUN = function(x) min(x$results[, metric]), simplify = T)
ind <- which(rmse_min == min(rmse_min))
### Returning result
return(best = m_list[[ind]])
}
install.packages("roxygen2")
install.packages("devtools")
install.packages("caret")
install.packages("CAST")
install.packages("pls")
install.packages("elasticnet")
install.packages("gbm")
install.packages("randomForest")
install.packages("bcaboot")
library(MachineControl)
library(MachineControl)
newdata <- as.PanelMLCM(y = data[, "Y"], timevar = data[, "year"], id = data[, "ID"],
x = data[, !(names(data) %in% c("Y", "ID", "year"))])
indices <- CAST::CreateSpacetimeFolds(newdata, timevar = "Time", k = 5)
indices$index
View(newdata)
indices$indexOut
unique(newdata$Time)
Tt <- length(unique(newdata[, "Time"]))
indices <- CreateSpacetimeFolds(newdata, timevar = "Time", k = Tt) # cambiare qui
indices <- CAST::CreateSpacetimeFolds(newdata, timevar = "Time", k = Tt) # cambiare qui
trainx <- lapply(pcv_block:(Tt-2), FUN = function(x) unlist(indices$indexOut[1:x]))
trainx <- lapply(1:(Tt-2), FUN = function(x) unlist(indices$indexOut[1:x]))
trainx
Tt <- sum(unique(newdata[, "Time"]) < int_date)
int_date <- 2020
Tt <- sum(unique(newdata[, "Time"]) < int_date)
indices <- CreateSpacetimeFolds(newdata, timevar = "Time", k = Tt)
indices <- CAST::CreateSpacetimeFolds(newdata, timevar = "Time", k = Tt)
trainx <- lapply(1:(Tt-1), FUN = function(x) unlist(indices$indexOut[1:x]))
testx <- lapply(1:(Tt-1), FUN = function(x) unlist(indices$indexOut[[x+1]]))
testx
trainx
indices$indexOut
library(CAST)
PanelCrossValidation <- function(data, int_date, pcv_block = 1, metric = "RMSE", trControl = NULL, ML_methods = NULL){
### Parameter checks
if(!any(class(data) %in% "PanelMLCM")) stop("Invalid class in the PanelCrossValidation function, something is wrong with as.PanelMLCM")
if(!(int_date %in% data[, "Time"])) stop("int_date must be contained in timevar")
if(length(unique(data[, "Time"])) - 2 - pcv_block < 1) stop("Panel cross validation must be performed in at least one time period")
if(pcv_block <= 0) stop("The number of 'pcv_block' time periods for panel cross validation must be at least 1")
if(!metric %in% c("RMSE", "Rsquared")) stop("Metric not allowed, check documentation")
if(is.list(ML_methods)){if(any(sapply(ML_methods, FUN = length) != 2)) stop("'ML_methods' must be a list of methods, each of length 2")}
if(is.list(ML_methods)){
if(any(sapply(ML_methods, FUN = function(x)(any(!names(x) %in% c("method", "tuneGrid")))))) stop("Each method in 'ML_methods' must be a named list, check documentation")}
### STEP 1. The CAST package is used to generate separate testing sets for each year
Tt <- length(unique(data[, "Time"]))
int_date <- int_date
indices <- CreateSpacetimeFolds(data, timevar = "Time", k = Tt)
trainx <- lapply(pcv_block:(Tt-2), FUN = function(x) unlist(indices$indexOut[1:x])) # cambiare qui
testx <- lapply(pcv_block:(Tt-2), FUN = function(x) unlist(indices$indexOut[[x+1]])) # cambiare qui
### STEP 2. Set control function by specifying the training and testing folds that caret will use
###         for cross-validation and tuning of the hyperparameters (i.e., the combination of folds defined above)
if(is.null(trControl)){
ctrl <- trainControl(index = trainx, indexOut = testx)
} else {
ctrl <- trControl # da capire come fare i param checks
}
if(is.null(ML_methods)){
# STOCHASTIC GRADIENT BOOSTING
gbmGrid <-  expand.grid(interaction.depth = c(1, 2, 3),
n.trees=c(500, 1000, 1500, 2000),
shrinkage = seq(0.01, 0.1, by = 0.01),
n.minobsinnode = c(10,20))
set.seed(1)
bo <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "gbm",
metric = metric,
trControl = ctrl,
tuneGrid = gbmGrid,
verbose = FALSE)
# RANDOM FOREST
set.seed(1)
rf <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "rf",
metric = metric,
search = "grid",
trControl = ctrl,
tuneGrid = expand.grid(mtry = (2:(ncol(data)-3))),
ntree=500)
# LASSO
lasso <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "lasso",
metric = metric,
trControl = ctrl,
tuneGrid = expand.grid(fraction = seq(0.1, 0.9, by = 0.1)),
preProc=c("center", "scale"))
# PLS
pls <- train(Y ~ .,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = "pls",
metric = metric,
trControl = ctrl,
tuneGrid = expand.grid(ncomp = c(1:10)),
preProc=c("center", "scale"))
# Storing results in a list
m_list <- list(bo = bo, rf = rf, lasso = lasso, pls = pls)
} else {
m_list <- lapply(ML_methods, FUN = function(x){train(Y ~.,
data = data[, !(names(data) %in% c("ID", "Time"))],
method = x$method,
metric = metric,
trControl = ctrl,
tuneGrid = x$tuneGrid)})
}
### STEP 4. Selecting the "best" ML algorithm based on the provided performance metric
rmse_min <- sapply(m_list, FUN = function(x) min(x$results[, metric]), simplify = T)
ind <- which(rmse_min == min(rmse_min))
### Returning result
return(best = m_list[[ind]])
}
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE)
end <- sum(unique(data[, "Time"]) < int_date)
trainx <- lapply(pcv_block:(end-1), FUN = function(x) unlist(indices$indexOut[1:x]))
trainx
testx <- lapply(pcv_block:(end-1), FUN = function(x) unlist(indices$indexOut[[x+1]]))
textx
testx
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE)
trainx
testx
View(fit)
View(fit)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE)
ind
View(data_panel)
ate
length(obs)
length(pred)
head(obs)
head(pred)
View(data_panel)
table(data_panel[-ind, "Time"], obs)
prova <- matrix(nrow = 2, obs - pred)
View(prova)
head(obs)
head(pred)
head(obs - pred)
rowmeans(prova)
rowMeans(prova)
length(data_panel[, "Time"] >= int_date)
unique(data_panel[, "Time"] >= int_date)
unique(data_panel[-ind, "Time"])
View(ate_boot)
View(ate_boot)
rownnames(ate_boot) <- data[-ind, "Time"]
rownames(ate_boot) <- data[-ind, "Time"]
View(ate_boot)
ate_boot <- cbind(data[-ind, "Time"], ate_boot)
View(ate_boot)
mapply(unique(data[-ind, "Time"]), FUN = function(x)(colMeans(ate_boot[ate_boot[,1] == x, -1])))
mapply(unique(data[-ind, "Time"]), FUN = function(x)(colMeans(ate_boot[ate_boot[,1] == x, -1])), SIMPLIFY = T)
prova <- mapply(unique(data[-ind, "Time"]), FUN = function(x)(colMeans(ate_boot[ate_boot[,1] == x, -1])), SIMPLIFY = T)
prova
View(prova)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE)
ate
View(mean_ate_boot)
mean_ate_boot <- mapply(unique(data[-ind, "Time"]), FUN = function(x)(colMeans(ate_boot[ate_boot[,1] == x, ])), SIMPLIFY = T)
View(ate_boot)
ate_boot <- data.frame(Time = unique(data[-ind, "Time"]), ate_boot)
View(ate_boot)
mean_ate_boot <- mapply(unique(data[-ind, "Time"]), FUN = function(x)(colMeans(ate_boot[ate_boot[,1] == x, -1])), SIMPLIFY = T)
View(mean_ate_boot)
conf.ate
View(conf.ate)
quantile(mean_ate_boot[,1], probs = c(0.025, 0.975))
prova <- quantile(mean_ate_boot[,1], probs = c(0.025, 0.975))
View(boot_inf)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE)
ate
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE)
ate
conf.ate
View(conf.ate)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "bc classic", nboot = 10, CATE = TRUE)
z0 <- mapply(mean_ate_boot, FUN = function(x)(qnorm(sum(x < ate)/nboot)), SIMPLIFY = TRUE)
z0 <- sapply(mean_ate_boot, FUN = function(x)(qnorm(sum(x < ate)/nboot)), SIMPLIFY = TRUE)
z0 <- sapply(mean_ate_boot, FUN = function(x)(qnorm(sum(x < ate)/nboot)), simplify  = TRUE)
z0 <- sapply(t(mean_ate_boot), FUN = function(x)(qnorm(sum(x < ate)/nboot)), SIMPLIFY = TRUE)
z0 <- mapply(t(mean_ate_boot), FUN = function(x)(qnorm(sum(x < ate)/nboot)), SIMPLIFY = TRUE)
View(mean_ate_boot)
z0 <- apply(mean_ate_boot, 2, FUN = function(x)(qnorm(sum(x < ate)/nboot)))
z0 <- mapply(x = mean_ate_boot, y = ate, FUN = function(x,y)(qnorm(sum(x < y)/nboot)), SIMPLIFY = TRUE)
ate
qnorm(sum(mean_ate_boot[,1] < ate[1])/nboot))
qnorm(sum(mean_ate_boot[,1] < ate[1])/nboot)
prova <- qnorm(sum(mean_ate_boot[,1] < ate[1])/nboot)
prova <- qnorm(sum(mean_ate_boot[,2] < ate[2])/nboot)
dim(mean_ate_boot)
View(dim(mean_ate_boot))
z0 <- mapply(x = mean_ate_boot, y = ate, FUN = function(x,y)(qnorm(sum(x < y)/nboot)), SIMPLIFY = FALSE)
z0 <- mapply(x = as.matrix(mean_ate_boot), y = ate, FUN = function(x,y)(qnorm(sum(x < y)/nboot)), SIMPLIFY = FALSE)
z0 <- mapply(x = apply(mean_ate_boot, 2, as.list), y = ate, FUN = function(x,y)(qnorm(sum(x < y)/nboot)), SIMPLIFY = FALSE)
View(z0)
z0 <- mapply(x = apply(mean_ate_boot, 2, as.list), y = ate, FUN = function(x,y)(qnorm(sum(x < y)/nboot)), SIMPLIFY = TRUE)
conf.ate <- apply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z)(quantile(z, probs = c(x,y))))
conf.ate <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z)(quantile(z, probs = c(x,y))))
conf.ate <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z)(quantile(z, probs = c(x,y))), SIMPLIFY = FALSE)
conf.ate <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z)(print(x); print(y); print(z)), SIMPLIFY = FALSE)
conf.ate <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){print(x); print(y); print(z)}, SIMPLIFY = FALSE)
View(conf.ate)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){print(x); print(y); print(z)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){print(z)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(z)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){print(z)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(x)}, SIMPLIFY = FALSE)
prova <- mapply(bia = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(bia)}, SIMPLIFY = FALSE)
prova <- mapply(bia = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(lower)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(lower)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(x)}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(length(x))}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(length(y))}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 1, as.list), FUN = function(x,y,z){print(length(z))}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){print(length(z))}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(z, probs = c(x,y))}, SIMPLIFY = FALSE)
prova <- mapply(x = as.list(lower), y = as.list(upper), z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(z, probs = c(x,y))}, SIMPLIFY = FALSE)
prova <- mapply(x = lower, y = upper, z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(z, probs = c(as.numeric(x),as.numeric(y)))}, SIMPLIFY = FALSE)
prova <- mapply(x = as.list(lower), y = as.list(upper), z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(z, probs = c(x[1],y[1]))}, SIMPLIFY = FALSE)
prova <- mapply(x = as.list(lower), y = as.list(upper), z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(z, probs = c(unlist(x),unlist(y)))}, SIMPLIFY = FALSE)
prova <- mapply(x = as.list(lower), y = as.list(upper), z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(unlist(z), probs = c(unlist(x),unlist(y)))}, SIMPLIFY = FALSE)
prova <- mapply(x = as.list(lower), y = as.list(upper), z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(unlist(z), probs = c(x,y))}, SIMPLIFY = FALSE)
prova <- mapply(x = as.list(lower), y = as.list(upper), z = apply(mean_ate_boot, 2, as.list), FUN = function(x,y,z){quantile(unlist(z), probs = c(x,y))}, SIMPLIFY = TRUE)
View(prova)
