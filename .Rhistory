inf_type = "block", nboot = 10, y.lag = 2)
ate
placebo_mean
cbind(as.matrix(placebo_mean), as.matrix(ate))
cbind(as.matrix(placebo_mean, nrow = 1), as.matrix(ate, nrow = 1))
as.matrix(placebo_mean, nrow = 1)
c(placebo_mean, ate)
int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40))
int_year <- rep(int_year_i, each = length(unique(data$year)))
# Define data_stag
data_stag <- data.frame(int_year, data)
# Estimation
fit <- StagMLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)
ate_i$int_2019$ate2
global_ate
group$time_eff
cohort_eff
ate_i$int_2019$ate2
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
fit$ate
fit$placebo.effects
fit$conf.ate
fit$conf.placebo
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
plot(fit, type = "ate")
plot(fit, type = "ate")
plot(fit, type = "ate")
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
fit$ate$estimate
fit$cate
plot(fit, type = "ate")
df
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
x.cate <- cbind(ID = rep(1:100, each = 2), year = rep(2019:2020, times = 100), x1 = rnorm(200),
x2 = 2*rnorm(200), x3 = sample(1:5, size = 200, replace = TRUE))
# Estimation
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 2, x.cate = x.cate)
fit$cate
fit$cate.inf
plot(fit$cate)
class(fit$cate)
names(fit$cate)
fit$cate
plot(fit$cate[[1]])
class(fit$cate[[1]])
text(fit$cate[[1]])
rpart.plot(fit$cate[[1]])
install.packages("rpart.plot")
rpart.plot(fit$cate[[1]])
library(rpart.plot)
rpart.plot(fit$cate[[1]])
help(rpart.plot)
rpart.plot(fit$cate)
rpart.plot(fit$cate[[1]])
rpart.plot(fit$cate[[2]])
fit$cate.inf
rpart.plot(fit$cate[[2]])
rpart.plot(fit$cate[[2]], model = TRUE)
x.cate <- cbind(ID = rep(1:100, each = 2), year = rep(2019:2020, times = 100), x1 = rnorm(200),
x2 = 2*rnorm(200), x3 = sample(1:5, size = 200, replace = TRUE))
# Estimation
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 2, x.cate = x.cate)
plot(fit, type = "cate")
plot(fit, type = "cate")
names(x$cate)
names(x$cate[[1]])
lapply(1:length(x$cate), function(i)(rpart.plot(x$cate[[i]], main = paste("CATE,", names(x$cate)[i]))))
rpart.plot(x$cate$2019)
x$cate$2019
length(x$cate)
x$cate[[1]]
x$cate$2019
rpart.plot(x$cate[[1]])
rpart.plot(x$cate[[1]], main = "CATE")
rpart.plot(x$cate[[1]], main = paste("CATE", names(x$cate)[i]))
rpart.plot(x$cate[[1]], main = paste("CATE", names(x$cate)[1]))
plot(fit, type = "cate")
prova <- plot(fit, type = "cate")
plot(fit, type = "cate", box.palette = "Greens")
plot(fit, type = c("ate", "cate"))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
fit$ate
head(fit$individual$estimate)
head(fit$individual$conf.interval)
head(data)
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(500, 1000),
shrinkage = seq(0.01, 0.1, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 500),
pls = list(ncomp = c(1:5)),
lasso = list(fraction = seq(0.1, 0.9, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(500, 1000),
shrinkage = seq(0.02, 0.8, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 500),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.8, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(100, 500),
shrinkage = seq(0.02, 0.8, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 500),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.8, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(100, 200),
shrinkage = seq(0.02, 0.6, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 100),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.6, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(100, 200),
shrinkage = seq(0.02, 0.6, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 100),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.6, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
gc()
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(100, 200),
shrinkage = seq(0.02, 0.6, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 100),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.6, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(100, 200),
shrinkage = seq(0.02, 0.6, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 500),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.6, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2,3),
n.trees = c(100, 200),
shrinkage = seq(0.02, 0.6, by = 0.02),
n.minobsinnode = c(10,20)),
rf = list(ntree = 100),
pls = list(ncomp = c(1:3)),
lasso = list(fraction = seq(0.2, 0.6, by = 0.1)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 5, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
seq(0.02, 0.6, by = 0.02)
seq(0.01, 0.1, by = 0.02)
seq(0.01, 0.1, by = 0.05)
seq(0.01, 0.11, by = 0.05)
seq(0.1, 0.9, by = 0.1)
seq(0.1, 0.9, by = 0.3)
seq(0.2, 0.6, by = 0.1)
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2),
n.trees = c(50, 100),
shrinkage = seq(0.01, 0.11, by = 0.05),
n.minobsinnode = c(10,20)),
rf = list(ntree = 50),
pls = list(ncomp = c(1:2)),
lasso = list(fraction = seq(0.1, 0.9, by = 0.3)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 5, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
gc()
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2),
n.trees = c(50, 100),
shrinkage = seq(0.01, 0.11, by = 0.05),
n.minobsinnode = c(10,20)),
rf = list(ntree = 50),
pls = list(ncomp = c(1:2)),
lasso = list(fraction = seq(0.1, 0.9, by = 0.3)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 5, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2),
n.trees = c(50, 100),
shrinkage = seq(0.01, 0.11, by = 0.05),
n.minobsinnode = c(20,40)),
rf = list(ntree = 50),
pls = list(ncomp = c(1:2)),
lasso = list(fraction = seq(0.1, 0.9, by = 0.3)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 5, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
old <- Sys.time()
default_par <- list(gbm = list(depth = c(1,2),
n.trees = c(10, 50),
shrinkage = seq(0.01, 0.6, by = 0.05),
n.minobsinnode = c(20,40)),
rf = list(ntree = 50),
pls = list(ncomp = c(1:2)),
lasso = list(fraction = seq(0.1, 0.9, by = 0.3)))
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 5, y.lag = 2, default_par = default_par)
new <- Sys.time()
new - old
plot(fit, type = "ate")
usethis::use_test("mlcm")
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
fit$ate$estimate
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c(-0.09861968, 0.02957445, -0.10848409, 79.89009226, 59.48719116))
devtools::load_all()
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c(-0.09861968, 0.02957445, -0.10848409, 79.89009226, 59.48719116))
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
exp <- c(-0.09861968, 0.02957445, -0.10848409, 79.89009226, 59.48719116),
names(exp) <- c('2016', '2017', '2018', '2019', '2020'),
exp)
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c(2016 = -0.09861968, 2017 = 0.02957445, 2018 = -0.10848409, 2019 = 79.89009226, 2020 = 59.48719116))
devtools::load_all()
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019, inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c(2016 = -0.09861968, 2017 = 0.02957445, 2018 = -0.10848409, 2019 = 79.89009226, 2020 = 59.48719116))
c(2016 = -0.09861968, 2017 = 0.02957445, 2018 = -0.10848409, 2019 = 79.89009226, 2020 = 59.48719116)
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116)
class(data)
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116))
test_that("MLCM works", {
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116))
})
test_that("MLCM works", {
expect_equal(MLCM(data = is.matrix(data), y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116))
})
int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40))
int_year <- rep(int_year_i, each = length(unique(data$year)))
# Define data_stag
data_stag <- data.frame(int_year, data)
# Estimation
fit <- StagMLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)
warnings()
fit$global_ate$estimate
expect_equal(int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40));
expect_equal(int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40)),
int_year <- rep(int_year_i, each = length(unique(data$year))),
data_stag <- data.frame(int_year, data),
StagMLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)$global_ate$estimate,
c("2016" = -1.8392615, "2017" = 0.5723790, "2018" = -0.3690107, "global_ate" = -0.1961546))
expect_equal(StagMLCM(data = data.frame(int_year, data), y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)$global_ate$estimate,
c("2016" = -1.8392615, "2017" = 0.5723790, "2018" = -0.3690107, "global_ate" = -0.1961546))
test_that("StagMLCM works", {
expect_equal(StagMLCM(data = data.frame(int_year, data), y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)$global_ate$estimate,
c("2016" = -1.8392615, "2017" = 0.5723790, "2018" = -0.3690107, "global_ate" = -0.1961546), tolerance = 10^(-4))
})
load("./refmod.Rdata")
load("~/GitHub/MLCM/data/data.rda")
str(data)
library(MachineControl)
str(data)
## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
#wd <- "C:/Users/fiamm/Documents/MLCM"
################################################################################
## Libraries and Functions
################################################################################
library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/RICERCA/MLCM/Codes/Sim_Functions.R")
source("~/RICERCA/MLCM/Codes/package.R")
# Parameters
# Tt <- c(6, 11, 21)              # Times (PRE + POST)
Tt <- c(8, 13, 23)
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
# NB. int_date is by default included in the post-int period,
# so for a single post intervention, set post_per <- 0
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)     # Coefficient of Xt-1
rho <- 0.8                     # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
### Impact settings
impact <- c(2,1.5)            # Fictional additive effect (it can be fixed or vary)
# impact <- 2
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev.
### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
### Checks
if(length(impact) != post_per + 1) stop("Impact must have length post_per + 1")
t <- Tt[1]
### Generating continuous covariates, varying across units
set.seed(6723)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
### Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
### Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
dim(X[[1]])
X[[1]]
data <- sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- data$dat
dim(data)
View(data)
ind <- which(is.na(data$Xlag1.x1))
ind
data <- data[-ind,]
dim(data)
rm(data)
library(MachineControl)
dim(data)
is.logical(TRUE)
is.logical(TRUE, FALSE)
usethis::use_data_raw()
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
class(X)
length(X)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
.sim_ardl <- function(seed, X, beta, ar1_coef, N, sigma, impact, impact_constant, ylag, xlag, linear = TRUE, post_per){
browser()
# Param checks
if(!is.numeric(seed) | seed < 0 ) stop (" 'seed' must be a number greater than 0") # include test in testthat
if(!is.list(X)) stop(" 'X' must be a list") # testthat it works with both
if(!is.numeric(beta)) stop (" 'beta' must be numeric") # test with testthat
# CHECK AR COEF
if(!is.integer(N) | N < 0) stop (" 'N' must be an integer") # test with testthat
if(!is.numeric(impact) | length(impact) != post_per +1) stop ("'impact' is non-numeric or it doesn't match 'post_per' ")
if(all(sapply(list(impact_constant, ylag, xlag, linear), is.logical))) stop ("supplied non-logical values to logical parameters")
# Settings
set.seed(seed)
t <- NROW(X[[1]])
# Do we want different covariates'values for different units?
# if(varying){
#  ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
#  X <- lapply(ran, function(x)(x + X))
# }
# Generating eps_it.
eps_it <- lapply(1:N, function(x)(rnorm(n = t, mean = 0, sd = sigma)))
# Generating Yit recursively (using 'y_recursive') for each i in 1:N
Yt <- mapply(FUN = .y_recursive, X = X, eps = eps_it, MoreArgs = list(beta, ar1_coef), linear = linear, SIMPLIFY = F)
# Adding fictional intervention
Y0 <- sapply(Yt, function(x) x[(t - post_per):t])
# Y0 <- sapply(Yt, function(x) x[t]) # old
if(impact_constant){
Yt <- lapply(Yt, function(x){x[(t - post_per):t] <- x[(t - post_per):t] + impact; x})
# Yt <- lapply(Yt, function(x){x[t] <- x[t] + impact; x}) # old
}  else {
Yt <- lapply(Yt, function(x){x[(t - post_per):t] <- x[(t - post_per):t] + impact*sd(x); x})
# Yt <- lapply(Yt, function(x){x[t] <- x[t] + impact*sd(x); x}) # old
}
# Dataset in long format
dat <- data.frame(ID = rep(1:N, each = t),
Y = unlist(Yt),
Xlag1 = do.call(rbind, lapply(X, function(x)(apply(x,2, .true_lag)))),
# X = do.call(rbind, X),
year = rep(seq(2020-t+1,2020), times = N))
# if(ylag){
#
#   # Lagged dependent variable
#   dat$Ylag1 <- unlist(lapply(Yt, FUN = .true_lag))
#   ind <- which(is.na(dat$Ylag1))
#
# } else {
#
#   ind <- which(is.na(dat$Xlag1.x1))
#
# }
# Removing initial NAs
# dat <- dat[-ind, ]
# Returning results (dataset + true ATE)
return(list(dat = dat,
true_ate = rowMeans(matrix(sapply(Yt, function(x) x[(t-post_per):t]) - Y0, nrow = post_per + 1))))
# true_ate = mean(sapply(Yt, function(x) x[t]) - Y0))) # old
}
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
N
is.integer(N)
class(N)
!all.equal(N, is.integer(N))
N
is.integer(N)
N %% 1
N %% 1 != 0
35 %% 1
35.4 %% 1
load_all()
library(devtools)
load_all()
