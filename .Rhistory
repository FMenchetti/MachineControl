ylags <- sapply(1:y.lag, FUN = function(x)(.true_lag(panel$Y, x)))
View(ylags)
ylags <- sapply(1:3, FUN = function(x)(.true_lag(panel$Y, x)))
View(panel)
View(panel)
seq(1, max.na)
library(MachineControl)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(ylags)
View(panel)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(ylags)
ylags <- mapply(l = 1:y.lag, id = unique(panel$ID), FUN = function(l, id)(.true_lag(panel$Y[panel$ID == id], l)))
prova <- unlist(lapply(ids, function(x)(.true_lag(panel$Y[panel$ID == x], 1))))
ids <- unique(panel$ID)
prova <- unlist(lapply(ids, function(x)(.true_lag(panel$Y[panel$ID == x], 1))))
prova
ylags <- sapply(1:y.lag, function(l){unlist(lapply(ids, function(x)(.true_lag(panel$Y[panel$ID == x], l))))})
View(ylags)
panel <- data.frame(panel, ylags)
View(panel)
View(panel)
colnames(ylags) <- paste0("Ylag", y.lag)
colnames(ylags) <- paste0("Ylag", 1:y.lag)
View(ylags)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
unique(timevar)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(panel)
View(panel)
prova <- NULL
prova > 0
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data_panel)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
length(unique(data[, "Time"]))
View(data)
Tt <- length(unique(data[, "Time"]))
indices <- CreateSpacetimeFolds(data, timevar = "Time", k = Tt)
end <- sum(unique(data[, "Time"]) < (int_date - 1) )
end
end <- sum(unique(data[, "Time"]) < int_date)
trainx <- lapply(pcv_block:end, FUN = function(x) unlist(indices$indexOut[1:x]))
testx <- lapply(pcv_block:end, FUN = function(x) unlist(indices$indexOut[[x+1]]))
end <- sum(unique(data[, "Time"]) < (int_date - 1) )
trainx <- lapply(pcv_block:end, FUN = function(x) unlist(indices$indexOut[1:x]))
testx <- lapply(pcv_block:end, FUN = function(x) unlist(indices$indexOut[[x+1]]))
length(unique(data[, "Time"])) - 2 - pcv_block
4-2-1 >1
4-2-1 >1
4-2-1 <1
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data)
View(data)
View(data)
View(data)
View(data)
unique(postimes)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 1)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 1)
int_date
View(data)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 1)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 1)
View(ylags)
paste0("Ylag", y.lag)
library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/MLCM/Codes/package.R")
# Parameters
# Tt <- c(6, 11, 21)              # Times (PRE + POST)
Tt <- c(8, 13, 23)
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
# NB. int_date is by default included in the post-int period,
# so for a single post intervention, set post_per <- 0
N <- 50                         # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
### Impact settings
impact <- c(2,1.5)            # Fictional additive effect (it can be fixed or vary)
# impact <- 2
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev.
### Inference settings
inf_type <- "block"           # Other option available "block bootstrap"
nboot <- 80                   # Number of bootstrap iterations
### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
ncore <- 2
### Checks
if(length(impact) != post_per + 1) stop("Impact must have length post_per + 1")
t <- Tt[1]
### Generating continuous covariates, varying across units
set.seed(6723)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
#x2 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 0.2)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
### Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
### Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
data <- sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
View(data$dat)
library(usethis)
data <- data$dat
usethis::use_data(data)
usethis::use_data(data, overwrite = TRUE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2, CATE = FALSE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2, CATE = FALSE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2, CATE = FALSE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = FALSE)
warnings()
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data_panel)
View(data)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2018,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data_panel)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data)
View(data)
## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
#wd <- "C:/Users/fiamm/Documents/MLCM"
################################################################################
## Libraries and Functions
################################################################################
library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/MLCM/Codes/package.R")
################################################################################
## Settings
################################################################################
# Parameters
# Tt <- c(6, 11, 21)              # Times (PRE + POST)
Tt <- c(8, 13, 23)
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
# NB. int_date is by default included in the post-int period,
# so for a single post intervention, set post_per <- 0
N <- 80                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)     # Coefficient of Xt-1
rho <- 0.8                     # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
### Impact settings
impact <- c(2,1.5)            # Fictional additive effect (it can be fixed or vary)
# impact <- 2
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev.
### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
### Checks
if(length(impact) != post_per + 1) stop("Impact must have length post_per + 1")
###########################################################
## Simulations
###########################################################
t <- Tt[1]
### Generating continuous covariates, varying across units
set.seed(6723)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
### Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
### Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
###########################################################
## Single dataset generation
###########################################################
data <- sim_ardl(seed = x*setseed, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
View(data$dat)
usethis::use_data(data, overwrite = TRUE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = FALSE, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
class(data)
################################################################################
##
## Simulation study
##
## Authors:      Cerqua A., Letta M., Menchetti F.
## Last update:  Feb 2023
##
################################################################################
## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
#wd <- "C:/Users/fiamm/Documents/MLCM"
################################################################################
## Libraries and Functions
################################################################################
## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/MLCM/Codes/package.R")
################################################################################
## Settings
################################################################################
# Parameters
# Tt <- c(6, 11, 21)              # Times (PRE + POST)
Tt <- c(8, 13, 23)
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
# NB. int_date is by default included in the post-int period,
# so for a single post intervention, set post_per <- 0
N <- 80                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)     # Coefficient of Xt-1
rho <- 0.8                     # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
### Impact settings
impact <- c(2,1.5)            # Fictional additive effect (it can be fixed or vary)
# impact <- 2
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev.
### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
### Checks
if(length(impact) != post_per + 1) stop("Impact must have length post_per + 1")
###########################################################
## Simulations
###########################################################
t <- Tt[1]
### Generating continuous covariates, varying across units
set.seed(6723)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
### Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
### Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
###########################################################
## Single dataset generation
###########################################################
data <- sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- data$dat
usethis::use_data(data, overwrite = TRUE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2, CATE = FALSE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
warnings()
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
warnings()
length(unique(postimes))
View(data)
View(data)
data[(post + i), paste0("Ylag",i)] <- pred - error
View(data)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data)
View(data)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)
View(data)
## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
#wd <- "C:/Users/fiamm/Documents/MLCM"
################################################################################
## Libraries and Functions
################################################################################
library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/MLCM/Codes/package.R")
################################################################################
## Settings
################################################################################
# Parameters
# Tt <- c(6, 11, 21)              # Times (PRE + POST)
Tt <- c(8, 13, 23)
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
# NB. int_date is by default included in the post-int period,
# so for a single post intervention, set post_per <- 0
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)     # Coefficient of Xt-1
rho <- 0.8                     # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
### Impact settings
impact <- c(2,1.5)            # Fictional additive effect (it can be fixed or vary)
# impact <- 2
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev.
### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
### Checks
if(length(impact) != post_per + 1) stop("Impact must have length post_per + 1")
###########################################################
## Simulations
###########################################################
t <- Tt[1]
### Generating continuous covariates, varying across units
set.seed(6723)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
### Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
### Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
###########################################################
## Single dataset generation
###########################################################
data <- sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- data$dat
View(data)
ind <- which(is.na(data$Xlag1.x1))
data <- data[-ind,]
View(data)
usethis::use_data(data, overwrite = TRUE)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 1)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, y.lag = 1)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 1)
fit$ate
c(fit$ate.lower, fit$ate.upper)
fit$conf.ate
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2020,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 1)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 1)
View(data)
library(MachineControl)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = T)
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 1)
fit$ate
fit$conf.ate
fit <- MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, CATE = TRUE, y.lag = 2)
fit$ate
fit$conf.ate
fit$cate.inf
source("~/MLCM/Codes/sim_code_local.R", echo=TRUE)
tab
newdata <- as.PanelMLCM(y = data[, "Y"], timevar = data[, "year"], id = data[, "ID"],
x = data[, !(names(data) %in% c("Y", "ID", "year"))], y.lag = 2)
head(newdata)
newdata <- as.PanelMLCM(y = data[, "Y"], timevar = data[, "year"], id = data[, "ID"],
x = data[, !(names(data) %in% c("Y", "ID", "year"))], y.lag = 2)
newdata <- as.PanelMLCM(y = data[, "Y"], timevar = data[, "year"], id = data[, "ID"],
x = data[, !(names(data) %in% c("Y", "ID", "year"))], y.lag = 1)
head(newdata)
indices <- CAST::CreateSpacetimeFolds(newdata, timevar = "Time", k = length(unique(data$year)))
indices <- CAST::CreateSpacetimeFolds(newdata, timevar = "Time", k = length(unique(newdata$year)))
indices <- CAST::CreateSpacetimeFolds(newdata, timevar = "Time", k = length(unique(newdata$Time)))
trainx <- indices$indexOut[1:2]
testx <- indices$indexOut[3:4]
ctrl <- trainControl(index = trainx, indexOut = testx)
pcv <- PanelCrossValidation(data = newdata, int_date = 2019, trControl = ctrl)
library(MachineControl)
library(MachineControl)
