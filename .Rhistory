# Define data_stag
data_stag <- data.frame(int_year, data)
# Estimation
fit <- MLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)
int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40))
int_year <- rep(int_year_i, each = length(unique(data$year)))
# Define data_stag
data_stag <- data.frame(int_year, data)
# Estimation
fit <- MLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)
pre
mat
rep(weights, 4)
matrix(weights, nrow = 4, ncol = 2)
matrix(weights, nrow = 4, ncol = 2, by row = T)
matrix(weights, nrow = 4, ncol = 2, byrow = T)
t(mat)
sapply(ate_i, FUN = function(x){eff <- x$placebo_effects
add <- pre[!pre %in% names(eff)]
eff <- c(eff, setNames(rep(0, length(add)), add))
})
table(panel_data$int_date)
table(data$int_date)
table(data_panel$int_date)
table(data_panel$Time)
pre
class(table(data_panel$int_date))
class(as.numeric(data_panel$int_date))
as.numeric(data_panel$int_date)
as.vector(data_panel$int_date)
as.numeric(table(data_panel$int_date))
as.vector(table(data_panel$int_date))
names(table(data_panel$int_date))
sapply(1:2, FUN = function(x){int.dates <- table(data_panel$int_date)
w <- int.dates/sum(int.dates)
ind <- which(unique(data_panel$Time) >= as.numeric(names(int.dates)))
w[ind] <- 0})
tab <- table(data_panel$int_date)
int.dates <- names(tab)
tab
int.dates
matrix(weights, 4, 2)
mat
mat2 <- mat
mat2
mat2 <- matrix(weigths, 4, 2)
mat2 <- matrix(weights, 4, 2)
mat2
placebo.weights <- matrix(weigths, 4, 2, byrow = T)
placebo.weights <- matrix(weights, 4, 2, byrow = T)
rownames(placebo.weights) <- rownames(mat)
colnames(placebo.weights) <- colnames(mat)
placebo.weights
gsub(colnames(mat), pattern = "int_", replacement = "")
int.dates <- unique(data_panel$int_date)
int.dates
unique(data_panel$Time[data_panel$Time < max(data_panel$int_date)])
pre.int <- unique(data_panel$Time[data_panel$Time < max(data_panel$int_date)])
pre.int >= int.dates[1]
int.dates <- unique(data_panel$int_date)
pre.int <- unique(data_panel$Time[data_panel$Time < max(int.dates)])
pre.int
rep(sum(data_panel$int_date == int.dates[1])/nrow(data_panel), length(pre.int))
pre.int >= min(int.dates)
sum(data_panel$int_date == 2020)/(nrow(data_panel)-sum(data_panel$int_date != 2020))
sum(data_panel$int_date == 2019)/(nrow(data_panel)-sum(data_panel$int_date != 2019))
sapply(int.dates, FUN = function(x){w <- rep(sum(data_panel$int_date == x)/nrow(data_panel), length(pre.int))
w[pre.int >= x] <- 0
if(x > min(int.dates)){w[pre.int >= min(int.dates)] <- sum(data_panel$int_date == x)/(nrow(data_panel)-sum(data_panel$int_date != x))}
})
sapply(int.dates, FUN = function(x){w <- rep(sum(data_panel$int_date == x)/nrow(data_panel), length(pre.int))
w[pre.int >= x] <- 0
if(x > min(int.dates)){w[pre.int >= min(int.dates)] <- sum(data_panel$int_date == x)/(nrow(data_panel)-sum(data_panel$int_date != x))}
w})
100/350
200/350
50/350
table(data_panel$int_date[data_panel$int_date>2018])
table(data_panel$int_date[data_panel$int_date>2019])
table(data_panel$int_date[data_panel$int_date>2019])/nrow(data_panel$int_date[data_panel$int_date>2019])
table(data_panel$int_date[data_panel$int_date>2019])/sum(data_panel$int_date>2019)
rm(list=ls())
library(MachineControl)
set.seed(1)
data <- read.csv("C:\\Users\\fiamm\\Downloads\\cs_mlcm.csv")
#data <- read.csv("G:\\Drive condivisi\\MLCM\\replication CS 2021\\cs_mlcm.csv")
names(data)
# Organizing the dataset with as.PanelMLCM
newdata <- as.PanelMLCM(y = data[, "lemp"], timevar = data[, "year"], id = data[, "countyreal"],
int_date = data[, "firsttreat"],
x = data[, !(names(data) %in% c("lemp", "countyreal", "year", "firsttreat"))], y.lag = 1)
#lm <- list(method = "lm",  tuneGrid = expand.grid(intercept=TRUE))
#gbmGrid <-  expand.grid(interaction.depth = c(1),
# n.trees=c(500),
# shrinkage = c(0.0001),
#  n.minobsinnode = c(10))
# gbm <- list(method="gbm", tuneGrid = gbmGrid)
rf <- list(method="rf", tuneGrid = expand.grid(mtry = c(3,6,9)), ntree=1000)
lambda <- 10^seq(-1000, 1000, length = 100)
lasso <- list(method="glmnet", tuneGrid = expand.grid(alpha = 1, lambda = lambda))
pcv <- PanelCrossValidationMulti(data = newdata, ML_methods = list(lasso, rf))
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
int.dates
pre.int
table(data$Time[data$int_date == int.dates[1]])
table(data$int.date[data$int_date > int.dates[1]])
table(data_panel$int_date[data_panel$int_date>2004])
1338+3504
nrow(data_panel)
table(data_panel$int_date[data_panel$int_date>2004])/sum(data_panel$int_date>2004)
sum(table(data_panel$int_date[data_panel$int_date>2004])/sum(data_panel$int_date>2004))
table(data_panel$int_date[data_panel$int_date>2005])/sum(data_panel$int_date>2005)
table(data_panel$int_date[data_panel$int_date>2006])/sum(data_panel$int_date>2006)
sapply(int.dates, FUN = function(x){table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)})
unique(data_panel$Time)!%in% pre.int
! unique(data_panel$Time)%in% pre.int
unique(data_panel$Time)
sort(unique(data_panel$Time[data_panel$Time>min(int.dates)]))
sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))
pre.int
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))
sapply(post.int, FUN = function(x){table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)})
table(data_panel$int_date[data_panel$int_date>2004])/sum(data_panel$int_date>2004)
prova <- table(data_panel$int_date[data_panel$int_date>2004])/sum(data_panel$int_date>2004)
names(prova)
add <- int.dates[which(!int.dates %in% names(prova))]
add
c(prova, setNames(rep(0, length(add)), add))
prova <- c(prova, setNames(rep(0, length(add)), add))
prova[order(names(prova))]
placebo.weights <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
placebo.weights
matrix(weights, nrow(mat), ncol(mat), byrow = T)
ate_i$int_2007$placebo_effects
eff <- ate_i$int_2007$placebo_effects
add <- pre[!pre %in% names(eff)]
pre <- as.character(pre.int)
pre
add <- pre[!pre %in% names(eff)]
eff <- ate_i$int_2004$placebo_effects
add <- pre[!pre %in% names(eff)]
add
eff
c(eff, setNames(rep(0, length(add)), add))
mat <- sapply(ate_i, FUN = function(x){eff <- x$placebo_effects
add <- pre[!pre %in% names(eff)]
eff <- c(eff, setNames(rep(0, length(add)), add))})
mat
placebo.weights
pre.int <- sort(unique(data_panel$Time[data_panel$Time < min(int.dates)]))
pre.int
matrix(weights, length(pre.int), length(int.dates), byrow = T)
weights
table(data_panel$int_date)
global_ate
sapply(ate_i, FUN = function(x)(mean(x$ate)))
unique(data_panel$int_date)
names(weights) <- unique(data_panel$int_date)
weights
matrix(weights, length(pre.int), length(int.dates), byrow = T)
int.dates <- sort(unique(data_panel$int_date))
pre.int <- sort(unique(data_panel$Time[data_panel$Time < min(int.dates)]))
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- unique(data_panel$int_date)
rownames(placebo.pre) <- pre.int
placebo.pre
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))[-length(post.int)]
placebo.weights <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
placebo.weights
t(placebo.weights)
unique(data_panel$Time)
unique(data_panel$Time[data_panel$Time>=min(int.dates)])
mat
int.dates <- sort(unique(data_panel$int_date))
pre.int <- sort(unique(data_panel$Time[data_panel$Time < min(int.dates)]))
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste("int_", unique(data_panel$int_date))
rownames(placebo.pre) <- pre.int
placebo.pre
post.int
placebo.post <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
placebo.post
gsub(rownames(placebo.post), patter="^", replacement = "int_")
colnames(placebo.post) <- post.int
rownames(placebo.post) <- gsub(rownames(placebo.post), patter="^", replacement = "int_")
placebo.post
t(placebo.post)
placebo.pre
placebo.pre[, order(colnames(placebo.pre))]
int.dates <- sort(unique(data_panel$int_date))
pre.int <- sort(unique(data_panel$Time[data_panel$Time < min(int.dates)]))
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste0("int_", unique(data_panel$int_date))
rownames(placebo.pre) <- pre.int
placebo.pre
placebo.pre <- placebo.pre[, order(colnames(placebo.pre))]
placebo.pre
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))[-length(post.int)]
placebo.post <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
colnames(placebo.post) <- post.int
rownames(placebo.post) <- gsub(rownames(placebo.post), patter="^", replacement = "int_")
placebo.pre
placebo.post
t(placebo.post)
placebo.weights <- rbind(placebo.pre, t(placebo.post))
placebo.weights
post.int
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))[-length(post.int)]
post.int
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))
post.int
int.dates <- sort(unique(data_panel$int_date))
pre.int <- sort(unique(data_panel$Time[data_panel$Time < min(int.dates)]))
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste0("int_", unique(data_panel$int_date))
rownames(placebo.pre) <- pre.int
placebo.pre <- placebo.pre[, order(colnames(placebo.pre))]
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))
post.int <- post.int[-length(post.int)]
placebo.post <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date>x])/sum(data_panel$int_date>x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
colnames(placebo.post) <- post.int
rownames(placebo.post) <- gsub(rownames(placebo.post), patter="^", replacement = "int_")
placebo.weights <- rbind(placebo.pre, t(placebo.post))
placebo.weights
mat
mat <- mat[order(colnames(mat))]
mat
mat <- sapply(ate_i, FUN = function(x){eff <- x$placebo_effects
add <- pre[!pre %in% names(eff)]
eff <- c(eff, setNames(rep(0, length(add)), add))})
mat <- mat[, order(colnames(mat))]
mat
placebo.weights
placebo.pre
placebo.weights <- cbind(t(placebo.pre), placebo.post)
placebo.weights
pre <- as.character(unique(data_panel$Time[data_panel$Time < max(int.dates)]))
mat <- sapply(ate_i, FUN = function(x){eff <- x$placebo_effects
add <- pre[!pre %in% names(eff)]
eff <- c(eff, setNames(rep(0, length(add)), add))})
mat <- t(mat[, order(colnames(mat))])
mat
placebo.weights
global_placebo <- mapply(x = mat, w = placebo.weights, FUN = weighted.mean, x = x, w = w) # riprendi da qui, fare in modo che dove ci sono gli 0 i pesi si devono redistribuire
global_placebo <- mapply(mat, placebo.weights, FUN = weighted.mean, x = mat, w = placebo.weights)
rm(list=ls())
library(MachineControl)
set.seed(1)
data <- read.csv("C:\\Users\\fiamm\\Downloads\\cs_mlcm.csv")
#data <- read.csv("G:\\Drive condivisi\\MLCM\\replication CS 2021\\cs_mlcm.csv")
names(data)
# Organizing the dataset with as.PanelMLCM
newdata <- as.PanelMLCM(y = data[, "lemp"], timevar = data[, "year"], id = data[, "countyreal"],
int_date = data[, "firsttreat"],
x = data[, !(names(data) %in% c("lemp", "countyreal", "year", "firsttreat"))], y.lag = 1)
#lm <- list(method = "lm",  tuneGrid = expand.grid(intercept=TRUE))
#gbmGrid <-  expand.grid(interaction.depth = c(1),
# n.trees=c(500),
# shrinkage = c(0.0001),
#  n.minobsinnode = c(10))
# gbm <- list(method="gbm", tuneGrid = gbmGrid)
rf <- list(method="rf", tuneGrid = expand.grid(mtry = c(3,6,9)), ntree=1000)
lambda <- 10^seq(-1000, 1000, length = 100)
lasso <- list(method="glmnet", tuneGrid = expand.grid(alpha = 1, lambda = lambda))
pcv <- PanelCrossValidationMulti(data = newdata, ML_methods = list(lasso, rf))
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
global_placebo <- mapply(x = mat, w = placebo.weights, FUN = function(x,w)(weighted.mean(x = x, w = w))) # riprendi da qui, fare in modo che dove ci sono gli 0 i pesi si devono redistribuire
global_placebo
mat
placebo.weights
mapply(x = mat, w = placebo.weights, FUN = function(x,w)(weighted.mean(x = x, w = w)))
sapply(1:3, FUN = function(i)(weighted.mean(mat[,i], w = placebo.weights[,i])))
sapply(1:ncol(mat), FUN = function(i)(weighted.mean(mat[,i], w = placebo.weights[,i])))
weighted.mean(mat[, "2002"], w = placebo.weights[,"2002"])
table(data_panel$int_date)/nrow(data_panel)
weighted.mean(mat[, "2002"], w = table(data_panel$int_date)/nrow(data_panel))
weighted.mean(mat[, "2003"], w = table(data_panel$int_date)/nrow(data_panel))
weighted.mean(mat[, "2004"], w = placebo.weights[,"2004"])
mat[, "2004"]
mat[-1, "2004"]
weighted.mean(mat[-1, "2004"], w = placebo.weights[-1,"2004"])
weighted.mean(mat[-1, "2005"], w = placebo.weights[-1,"2005"])
rm(list=ls())
library(MachineControl)
set.seed(1)
data <- read.csv("C:\\Users\\fiamm\\Downloads\\cs_mlcm.csv")
#data <- read.csv("G:\\Drive condivisi\\MLCM\\replication CS 2021\\cs_mlcm.csv")
names(data)
# Organizing the dataset with as.PanelMLCM
newdata <- as.PanelMLCM(y = data[, "lemp"], timevar = data[, "year"], id = data[, "countyreal"],
int_date = data[, "firsttreat"],
x = data[, !(names(data) %in% c("lemp", "countyreal", "year", "firsttreat"))], y.lag = 1)
#lm <- list(method = "lm",  tuneGrid = expand.grid(intercept=TRUE))
#gbmGrid <-  expand.grid(interaction.depth = c(1),
# n.trees=c(500),
# shrinkage = c(0.0001),
#  n.minobsinnode = c(10))
# gbm <- list(method="gbm", tuneGrid = gbmGrid)
rf <- list(method="rf", tuneGrid = expand.grid(mtry = c(3,6,9)), ntree=1000)
lambda <- 10^seq(-1000, 1000, length = 100)
lasso <- list(method="glmnet", tuneGrid = expand.grid(alpha = 1, lambda = lambda))
pcv <- PanelCrossValidationMulti(data = newdata, ML_methods = list(lasso, rf))
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
global_ate
conf.global.ate
class(boot_inf$int_2007$placebo_boot)
dim(boot_inf$int_2007$placebo_boot)
View(boot_inf$int_2007$placebo_boot)
View(boot_inf$int_2007$ate_boot)
View(boot_inf$int_2004$ate_boot)
ate_i$int_2004
sapply(boot_inf, FUN = function(x)(rowMeans(x$ate_boot)))
table(data_panel$int_date)
nrow(data_panel)
weighted.mean(c(0.008014044,0.14462474), w = c(1338/(1338+600), 600/(1338+600)))
weighted.mean(c(-0.0218671 ,-0.021043432, 0.13563419), w = c(3504/5442, 1338/5442, 600/5442))
mean(c(-0.09327978, -0.12856871, 0.05030838, -0.004299507))
View(boot_inf$int_2007$placebo_boot)
sapply(boot_inf, FUN = function(x)(rowMeans(x$placebo_boot)))
sapply(boot_inf, FUN = function(x)(quantile(x$placebo_boot, probs = c(alpha/2, 1- alpha/2))))
sapply(boot_inf, FUN = function(x)(apply(x$placebo_boot, quantile, probs = c(alpha/2, 1- alpha/2))))
sapply(boot_inf, FUN = function(x)(apply(x$placebo_boot, FUN = quantile, probs = c(alpha/2, 1- alpha/2))))
sapply(boot_inf, FUN = function(x)(apply(x$placebo_boot, 1, FUN = quantile, probs = c(alpha/2, 1- alpha/2))))
placebo.pre
post.int
placebo.post
table(data_panel$int_date[data_panel$int_date>2004])/sum(data_panel$int_date>2004)
table(data_panel$int_date[data_panel$int_date<=2004])/sum(data_panel$int_date<=2004)
table(data_panel$int_date[data_panel$int_date<=2005])/sum(data_panel$int_date<=2005)
w <- table(data_panel$int_date[data_panel$int_date<=2005])/sum(data_panel$int_date<=2005)
int.dates[which(!int.dates %in% names(w))]
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w
w <- table(data_panel$int_date[data_panel$int_date<=2006])/sum(data_panel$int_date<=2006)
w
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w
w <- table(data_panel$int_date[data_panel$int_date<=2007])/sum(data_panel$int_date<=2007)
w
placebo.post <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date<=x])/sum(data_panel$int_date<=x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
placebo.post
colnames(placebo.post) <- post.int
rownames(placebo.post) <- gsub(rownames(placebo.post), patter="^", replacement = "int_")
placebo.post
600/(5442-sum(data_panel$int_date==2007))
1338/(5442-sum(data_panel$int_date==2007))
cbind(t(placebo.pre), placebo.post)
sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))
post.int <- sort(unique(data_panel$Time[data_panel$Time>=min(int.dates)]))
#post.int <- post.int[-length(post.int)]
# Group-average effects at each time post-intervention: global weights post-intervention
placebo.post <- sapply(post.int, FUN = function(x){w <- table(data_panel$int_date[data_panel$int_date<=x])/sum(data_panel$int_date<=x)
add <- int.dates[which(!int.dates %in% names(w))]
w <- c(w, setNames(rep(0, length(add)), add))
w <- w[order(names(w))]})
rm(list=ls())
library(MachineControl)
set.seed(1)
data <- read.csv("C:\\Users\\fiamm\\Downloads\\cs_mlcm.csv")
#data <- read.csv("G:\\Drive condivisi\\MLCM\\replication CS 2021\\cs_mlcm.csv")
names(data)
# Organizing the dataset with as.PanelMLCM
newdata <- as.PanelMLCM(y = data[, "lemp"], timevar = data[, "year"], id = data[, "countyreal"],
int_date = data[, "firsttreat"],
x = data[, !(names(data) %in% c("lemp", "countyreal", "year", "firsttreat"))], y.lag = 1)
#lm <- list(method = "lm",  tuneGrid = expand.grid(intercept=TRUE))
#gbmGrid <-  expand.grid(interaction.depth = c(1),
# n.trees=c(500),
# shrinkage = c(0.0001),
#  n.minobsinnode = c(10))
# gbm <- list(method="gbm", tuneGrid = gbmGrid)
rf <- list(method="rf", tuneGrid = expand.grid(mtry = c(3,6,9)), ntree=1000)
lambda <- 10^seq(-1000, 1000, length = 100)
lasso <- list(method="glmnet", tuneGrid = expand.grid(alpha = 1, lambda = lambda))
pcv <- PanelCrossValidationMulti(data = newdata, ML_methods = list(lasso, rf))
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
int.dates
pre.int
post.int
weights
global.weights
placebo.pre
weights <- table(data$int_date)/nrow(data)
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste0("int_", unique(data$int_date))
rownames(placebo.pre) <- pre.int
placebo.pre
weights
weights <- table(data$int_date)/nrow(data)
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste0("int_", unique(data$int_date))
rownames(placebo.pre) <- names(weights)
weights <- table(data$int_date)/nrow(data)
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste0("int_", names(weights))
rownames(placebo.pre) <- pre.int
placebo.weights
placebo.pre
int.dates <- sort(unique(data$int_date))
pre.int <- sort(unique(data$Time[data$Time < min(int.dates)]))
post.int <- sort(unique(data$Time[data$Time>=min(int.dates)]))
### STEP 1. Weights pre-intervention
weights <- table(data$int_date)/nrow(data)
placebo.pre <- matrix(weights, length(pre.int), length(int.dates), byrow = T)
colnames(placebo.pre) <- paste0("int_", names(weights))
rownames(placebo.pre) <- pre.int
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
global.weights
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
ate_i[[1]]$placebo_effects
ate_i[[1]]$ate
sapply(ate_i, FUN = function(x)(c(x$placebo_effects, x$ate)))
ate_i[[2]]$placebo_effects
ate_i[[2]]$ate
ate_i[[3]]$placebo_effects
c(pre.int, post.int)
mat <- sapply(ate_i, FUN = function(x)(c(x$placebo_effects, x$ate)))
rownames(mat) <- c(pre.int, post.int)
mat <- mat[, order(colnames(mat))]
mat
global.weights <- cbind(placebo.pre, t(placebo.post))
global.weights <- rbind(placebo.pre, t(placebo.post))
global.weights
groupavg_eff <- sapply(1:nrow(mat), FUN = function(i)(weighted.mean(mat[i,], w = global.weights[i,])))
groupavg_eff
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
global.weights
mat
View(rbind(boot_inf[[1]]$placebo_boot, boot_inf[[1]]$ate))
apply(rbind(boot_inf[[1]]$placebo_boot, boot_inf[[1]]$ate), 1, FUN = quantile, probs = c(alpha/2, 1- alpha/2))
group$time_eff
group$global.weights
prova <- sapply(boot_inf, FUN = function(x)(apply(rbind(x$placebo_boot, x$ate), 1, FUN = quantile, probs = alpha/2)))
prova
lower <- sapply(boot_inf, FUN = function(x)(apply(rbind(x$placebo_boot, x$ate), 1, FUN = quantile, probs = alpha/2)))
lower <- lower[, order(colnames(lower))]
lower
apply(1:nrow(lower), FUN = function(i)(weighted.mean(lower[i,], w = group$global.weights[i,])))
sapply(1:nrow(lower), FUN = function(i)(weighted.mean(lower[i,], w = group$global.weights[i,])))
sapply(1:nrow(upper), FUN = function(i)(weighted.mean(upper[i,], w = group$global.weights[i,])))
lower <- sapply(boot_inf, FUN = function(x)(apply(rbind(x$placebo_boot, x$ate), 1, FUN = quantile, probs = alpha/2)))
lower <- lower[, order(colnames(lower))]
group.lower <- sapply(1:nrow(lower), FUN = function(i)(weighted.mean(lower[i,], w = group$global.weights[i,])))
upper <- sapply(boot_inf, FUN = function(x)(apply(rbind(x$placebo_boot, x$ate), 1, FUN = quantile, probs = 1- alpha/2)))
upper <- upper[, order(colnames(upper))]
group.upper <- sapply(1:nrow(upper), FUN = function(i)(weighted.mean(upper[i,], w = group$global.weights[i,])))
group.lower
group.upper
group$groupavg_eff
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
rownames(group$groupavg_eff)
names(group$groupavg_eff)
colnames(conf.groupavg)
conf.groupavg
conf.groupavg <- rbind(group.lower, group.upper)
conf.groupavg
colnames(conf.groupavg) <- names(group$groupavg_eff)
rownames(conf.groupavg) <- c(alpha/2, 1- alpha/2)
conf.groupavg
fit <- MLCM(data = newdata, int_date = "int_date",
inf_type = "block", nboot = 1000, CATE = FALSE, PCV=pcv, y.lag=1)
fit$groupavg
fit$conf.groupavg
plot(fit$group_ate)
plot(fit$groupavg)
ylim <- c(min(fit$conf.groupavg[1,]), max(fit$conf.groupavg[2,]))
plot(fit$groupavg, ylim = ylim, pch = 16, col = "blue")
points(fit$conf.groupavg[1,], pch = 3, col = "red")
points(fit$conf.groupavg[2,], pch = 3, col = "red")
abline(h = 0, lty = "dashed", col = "black")
mean(fit$groupavg[3:6])
points(fit$global_ate, pch = 16, col = "green")
points(fit$global_ate, pch = 16, col = "white")
points(x = 3, y = fit$global_ate, pch = 16, col = "green")
points(x = 3, y = fit$conf.global.ate[1], pch = 3, col = "red")
points(x = 3, y = fit$conf.global.ate[2], pch = 3, col = "red")
