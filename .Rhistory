expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
exp <- c(-0.09861968, 0.02957445, -0.10848409, 79.89009226, 59.48719116),
names(exp) <- c('2016', '2017', '2018', '2019', '2020'),
exp)
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c(2016 = -0.09861968, 2017 = 0.02957445, 2018 = -0.10848409, 2019 = 79.89009226, 2020 = 59.48719116))
devtools::load_all()
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019, inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c(2016 = -0.09861968, 2017 = 0.02957445, 2018 = -0.10848409, 2019 = 79.89009226, 2020 = 59.48719116))
c(2016 = -0.09861968, 2017 = 0.02957445, 2018 = -0.10848409, 2019 = 79.89009226, 2020 = 59.48719116)
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116)
class(data)
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116))
test_that("MLCM works", {
expect_equal(MLCM(data = data, y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116))
})
test_that("MLCM works", {
expect_equal(MLCM(data = is.matrix(data), y = "Y", timevar = "year", id = "ID", int_date = 2019,
inf_type = "classic", nboot = 10, y.lag = 2)$ate$estimate,
c("2016" = -0.09861968, "2017" = 0.02957445, "2018" = -0.10848409, "2019" = 79.89009226, "2020" = 59.48719116))
})
int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40))
int_year <- rep(int_year_i, each = length(unique(data$year)))
# Define data_stag
data_stag <- data.frame(int_year, data)
# Estimation
fit <- StagMLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)
warnings()
fit$global_ate$estimate
expect_equal(int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40));
expect_equal(int_year_i <- c(rep(2019, times = 60), rep(2020, times = 40)),
int_year <- rep(int_year_i, each = length(unique(data$year))),
data_stag <- data.frame(int_year, data),
StagMLCM(data = data_stag, y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)$global_ate$estimate,
c("2016" = -1.8392615, "2017" = 0.5723790, "2018" = -0.3690107, "global_ate" = -0.1961546))
expect_equal(StagMLCM(data = data.frame(int_year, data), y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)$global_ate$estimate,
c("2016" = -1.8392615, "2017" = 0.5723790, "2018" = -0.3690107, "global_ate" = -0.1961546))
test_that("StagMLCM works", {
expect_equal(StagMLCM(data = data.frame(int_year, data), y = "Y", timevar = "year", id = "ID", int_date = "int_year",
inf_type = "block", nboot = 10, y.lag = 2)$global_ate$estimate,
c("2016" = -1.8392615, "2017" = 0.5723790, "2018" = -0.3690107, "global_ate" = -0.1961546), tolerance = 10^(-4))
})
load("./refmod.Rdata")
load("~/GitHub/MLCM/data/data.rda")
str(data)
library(MachineControl)
str(data)
## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
#wd <- "C:/Users/fiamm/Documents/MLCM"
################################################################################
## Libraries and Functions
################################################################################
library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/RICERCA/MLCM/Codes/Sim_Functions.R")
source("~/RICERCA/MLCM/Codes/package.R")
# Parameters
# Tt <- c(6, 11, 21)              # Times (PRE + POST)
Tt <- c(8, 13, 23)
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
# NB. int_date is by default included in the post-int period,
# so for a single post intervention, set post_per <- 0
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)     # Coefficient of Xt-1
rho <- 0.8                     # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
### Impact settings
impact <- c(2,1.5)            # Fictional additive effect (it can be fixed or vary)
# impact <- 2
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev.
### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
### Checks
if(length(impact) != post_per + 1) stop("Impact must have length post_per + 1")
t <- Tt[1]
### Generating continuous covariates, varying across units
set.seed(6723)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
### Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
### Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
dim(X[[1]])
X[[1]]
data <- sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- data$dat
dim(data)
View(data)
ind <- which(is.na(data$Xlag1.x1))
ind
data <- data[-ind,]
dim(data)
rm(data)
library(MachineControl)
dim(data)
is.logical(TRUE)
is.logical(TRUE, FALSE)
usethis::use_data_raw()
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
class(X)
length(X)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
.sim_ardl <- function(seed, X, beta, ar1_coef, N, sigma, impact, impact_constant, ylag, xlag, linear = TRUE, post_per){
browser()
# Param checks
if(!is.numeric(seed) | seed < 0 ) stop (" 'seed' must be a number greater than 0") # include test in testthat
if(!is.list(X)) stop(" 'X' must be a list") # testthat it works with both
if(!is.numeric(beta)) stop (" 'beta' must be numeric") # test with testthat
# CHECK AR COEF
if(!is.integer(N) | N < 0) stop (" 'N' must be an integer") # test with testthat
if(!is.numeric(impact) | length(impact) != post_per +1) stop ("'impact' is non-numeric or it doesn't match 'post_per' ")
if(all(sapply(list(impact_constant, ylag, xlag, linear), is.logical))) stop ("supplied non-logical values to logical parameters")
# Settings
set.seed(seed)
t <- NROW(X[[1]])
# Do we want different covariates'values for different units?
# if(varying){
#  ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
#  X <- lapply(ran, function(x)(x + X))
# }
# Generating eps_it.
eps_it <- lapply(1:N, function(x)(rnorm(n = t, mean = 0, sd = sigma)))
# Generating Yit recursively (using 'y_recursive') for each i in 1:N
Yt <- mapply(FUN = .y_recursive, X = X, eps = eps_it, MoreArgs = list(beta, ar1_coef), linear = linear, SIMPLIFY = F)
# Adding fictional intervention
Y0 <- sapply(Yt, function(x) x[(t - post_per):t])
# Y0 <- sapply(Yt, function(x) x[t]) # old
if(impact_constant){
Yt <- lapply(Yt, function(x){x[(t - post_per):t] <- x[(t - post_per):t] + impact; x})
# Yt <- lapply(Yt, function(x){x[t] <- x[t] + impact; x}) # old
}  else {
Yt <- lapply(Yt, function(x){x[(t - post_per):t] <- x[(t - post_per):t] + impact*sd(x); x})
# Yt <- lapply(Yt, function(x){x[t] <- x[t] + impact*sd(x); x}) # old
}
# Dataset in long format
dat <- data.frame(ID = rep(1:N, each = t),
Y = unlist(Yt),
Xlag1 = do.call(rbind, lapply(X, function(x)(apply(x,2, .true_lag)))),
# X = do.call(rbind, X),
year = rep(seq(2020-t+1,2020), times = N))
# if(ylag){
#
#   # Lagged dependent variable
#   dat$Ylag1 <- unlist(lapply(Yt, FUN = .true_lag))
#   ind <- which(is.na(dat$Ylag1))
#
# } else {
#
#   ind <- which(is.na(dat$Xlag1.x1))
#
# }
# Removing initial NAs
# dat <- dat[-ind, ]
# Returning results (dataset + true ATE)
return(list(dat = dat,
true_ate = rowMeans(matrix(sapply(Yt, function(x) x[(t-post_per):t]) - Y0, nrow = post_per + 1))))
# true_ate = mean(sapply(Yt, function(x) x[t]) - Y0))) # old
}
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
N
is.integer(N)
class(N)
!all.equal(N, is.integer(N))
N
is.integer(N)
N %% 1
N %% 1 != 0
35 %% 1
35.4 %% 1
load_all()
library(devtools)
load_all()
rm(list=ls())
library(devtools)
load_all()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
help(mvrnorm)
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- MASS::mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = MASS::mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
#### STEP 3. Single dataset generation
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
sapply(list(impact_constant, ylag, linear), is.logical)
all(sapply(list(impact_constant, ylag, linear), is.logical))
any(sapply(list(impact_constant, ylag, linear), is.logical))
any(TRUE,TRUE,FALSE)
all(TRUE,TRUE,FALSE)
load_all()
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- MASS::mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = MASS::mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
#### STEP 3. Single dataset generation
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
load_all()
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- MASS::mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = MASS::mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
#### STEP 3. Single dataset generation
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
ylag = FALSE, linear = linear, post_per = post_per)
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- MASS::mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = MASS::mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
#### STEP 3. Single dataset generation
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
linear = linear, post_per = post_per)
View(data$dat)
## Code to prepare `DATA` dataset
#### STEP 1. Setting arguments for function .sim_ardl()
## Parameters
seed <- 1                       # Seed to ensure exact replication of the dataset
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 100                        # Number of units in the panel
beta <- c(0, 1, 2.5, 0.1,
0, 0, 2, 1.5)         # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
## Linear or non linear model?
linear <- TRUE
## Impact settings
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE        # Set to FALSE for additive impact proportional to std.dev(Yt).
#### STEP 2. Simulating covariates
t <- 8
## Generating continuous covariates, varying across units
set.seed(seed)
x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
xm <- MASS::mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
X <- cbind(x1 = x1, x2 = xm[,1], x3 = xm[,2], x4 = xm[,3])
ran <- lapply(1:N, FUN = MASS::mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})
## Generating categorical covariates, varying across units
x5 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
x6 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))
## Binding and adding interactions
X <- mapply(X, x5, x6, FUN = function(X, x5, x6)(cbind(X, x5, x6, x7 = X[,3]*x6, x8 = X[,2]*x5)), SIMPLIFY = F)
#### STEP 3. Single dataset generation
data <- .sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
linear = linear, post_per = post_per)
View(dat)
X[[1]]
View(rbind(X[[1]],X[[2]]))
colnames(dat)
gsub(colnames(dat), pattern = ".x", replacement = ".")
names(dat)
names(data)
load_all()
class(X)
class(X[[1]])
source("~/GitHub/MLCM/data-raw/DATASET.R", echo=TRUE)
str(data)
load_all()
source("~/GitHub/MLCM/data-raw/DATASET.R", echo=TRUE)
use_test(".sim_ardl")
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 10                         # Number of units in the panel
beta <- c(1, 2.5, 0.1)          # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
t <- 7
prova <- lapply(1:N, FUN = function(x)(cbind(x1 = seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1), x2 = sample(0:1, t, replace = TRUE), x3=sample(1:3, t, replace = TRUE))))
class(prova)
length(prova)
View(prova)
View(prova[[1]])
View(do.call(cbind(prova)))
View(do.call(cbind, prova))
test_that(".sim_ardl works", {
## param
post_per <- 1                   # Number of post-intervention periods (excluding int_date)
N <- 10                         # Number of units in the panel
beta <- c(1, 2.5, 0.1)          # Coefficient of Xt-1
rho <- 0.8                      # Coefficient of Yt-1
sigma <- 2                      # St.dev of the error term
impact <- c(2,1.5)              # Fictional additive effect (it can be fixed or vary)
t <- 7
X <- lapply(1:N, FUN = function(x)(cbind(x1 = seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1),
x2 = sample(0:1, t, replace = TRUE),
x3=sample(1:3, t, replace = TRUE))))
## tests
expect_error(.sim_ardl(seed = 1, beta = beta, X = do.call(cbind, X), N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
linear = linear, post_per = post_per))
})
expect_error(.sim_ardl(seed = 1, beta = beta, X = X, N = N, sigma = sigma,
ar1_coef = rho, impact = impact, impact_constant = impact_constant,
linear = linear, post_per = 2))
