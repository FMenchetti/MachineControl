################################################################################
##
## Simulation study
##
## Authors:      Cerqua A., Letta M., Menchetti F.
## Last update:  Feb 2023
##
################################################################################

## Cleaning and setting directory
rm(list = ls())
set.seed(6723)
#wd <- "C:/Users/fiamm/Documents/MLCM"

################################################################################
## Libraries and Functions
################################################################################

# MODIFICA QUI: FUNZIONE DI SETUP CHE SETTA L'ENVIRONMENT CON TUTTI I PACCHETTI NECESSARI
# importante anche per ClusterMap. N.B. Prima o poi, i pacchetti chiamati qui vanno
# inseriti tra le dipendenze del nostro, così non importerà più richiamarli

library(CAST)
library(caret)
library(gbm)
library(elasticnet)
library(parallel)
library(MASS)
library(bcaboot)
library(pls)
library(stats)
library(utils)
library(randomForest)
library(rpart)
library(abind)
source("~/MLCM/Codes/Sim_Functions.R")
source("~/MLCM/Codes/package.R")

################################################################################
## Settings
################################################################################

# Parameters
Tt <- c(6, 11, 21)             # Times (PRE + POST)
post_per <- 0                   # Number of post-intervention periods (excluding int_date)
                                # NB. int_date is by default included in the post-int period,
                                # so for a single post intervention, set post_per <- 0
N <- 100                        # Number of units in the panel
beta <- c(0, 2, 1, 2.5, 0.1, 2,
          1, 0, 0, 2, 1.5)       # Coefficient of Xt-1
rho <- 0.8                       # Coefficient of Yt-1
sigma <- 2                       # St.dev of the error term

### Linear or non linear model?
linear <- TRUE                  # set to 'FALSE' for non-linear specification
y.lag <- 1

### Impact settings
impact <- 2            # Fictional additive effect (it can be fixed or vary)
impact_constant <- FALSE         # Set to FALSE for additive impact proportional to std.dev.

### Inference settings
inf_type <- "classic"            # Other option available "block bootstrap"
nboot <- 80                    # Number of bootstrap iterations

### Parallel settings
niter <- 1                      # Number of iterations for each t in Tt
ncore <- 3

###########################################################
## Simulations
###########################################################
t <- Tt[1]
#for(t in Tt){
  set.seed(6723)
  ### Generating continuous covariates, varying across units
  x1 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 1)
  x2 <- seq(0.2, by = 0.1, length.out = t) + rnorm(t, 0, 0.2)
  xm <- mvrnorm(n = t, mu = c(1,2,3), Sigma = matrix(c(1,0.5,0.7,0.5, 1, 0.3, 0.7, 0.3, 1), nrow = 3, ncol = 3))
  x6 <- -rnorm(t)
  x7 <- x1^2 + rnorm(t, 0, 0.2)
  X <- cbind(x1 = x1, x2 = x2, x3 = xm[,1], x4 = xm[,2], x5 = xm[,3], x6 = x6, x7 = x7)
  ran <- lapply(1:N, FUN = mvrnorm, n = NROW(X) , mu = rep(1, ncol(X)), Sigma = 0.1*diag(1, nrow = ncol(X), ncol = ncol(X)))
  X <- lapply(ran, function(x){y <- x + X; colnames(y) <- colnames(X); y})

  ### Generating categorical covariates, varying across units
  x8 <- lapply(1:N, FUN = function(x)(sample(0:1, t, replace = TRUE)))
  x9 <- lapply(1:N, FUN = function(x)(sample(1:3, t, replace = TRUE)))

  ### Binding and adding interactions
  X <- mapply(X, x8, x9, FUN = function(X, x8, x9)(cbind(X, x8, x9, x10 = X[,3]*x9, x11 = X[,2]*x8)), SIMPLIFY = F)

  ### Setting PCV blocking
  block <- t - 5

  ## Step 1: Create a cluster of child processes
  cl <- makeCluster( ncore ) # we're saying we want the operation to run on 4 cores at the same time

  ## Step 2: Distribute the necessary R objects
  clusterExport( cl, c('N','beta','rho','sigma','X','post_per','impact','y.lag')) # every object needed for the estimation has to be included in the cluster

  ## Step 3: Loading all needed libraries and/or custom functions in the cluster
  par.setup <- parLapply( cl, 1:length(cl),
                          function(x) {
                            library(parallel)
                            library(CAST)
                            library(caret)
                            library(gbm)
                            library(elasticnet)
                            library(MASS)
                            library(bcaboot)
                            library(pls)
                            library(stats)
                            library(utils)
                            library(randomForest)
                            library(rpart)
                            library(abind)
                            source("~/MLCM/Codes/Sim_Functions.R")
                            source("~/MLCM/Codes/package.R")
                          })

  ## Step 4: Do the computation
  inf_par <- clusterMap(cl = cl, fun = PanelSIM, niter = rep(niter, ncore), setseed = seq(5290, by = 1, length.out = ncore), 
                        MoreArgs = list(gen_mod = "ardl", N = N, impact = impact, X = X, beta = beta, sigma = sigma, ar1_coef = rho, 
                                        linear = linear, pcv_block = block, inf_type = inf_type, impact_constant = impact_constant, 
                                        nboot =nboot, post_per = post_per, y.lag))
  
  
  ## Step 5: Remember to stop the cluster!
  stopCluster(cl)

  ###########################################################
  ## Merging clusters results
  ###########################################################
  
  # Tabulating
  T1 <- do.call(rbind, lapply(inf_par, FUN = function(x)(x$tab[,,1])))
  tab <- T1
  # T2 <- do.call(rbind, lapply(inf_par, FUN = function(x)(x$tab[,,2])))
  # tab <- abind(T1,T2, along = 3)
  # T3 <- do.call(rbind, lapply(inf_par, FUN = function(x)(x$tab[,,3])))
  # tab <- abind(T1,T2,T3, along = 3)
  best_method <- do.call(c, lapply(inf_par, FUN = function(x)(x$Best_method)))
  
  # Saving
#  saveRDS(tab, file = paste0("~/MLCM/sim_", inf_type,"_linear_", linear, "_constant_" , impact_constant,"_",t, ".RDS"))
#  saveRDS(best_method, file = paste0("~/MLCM/sim_method_", inf_type,"_linear_", linear, "_constant_" , impact_constant,"_",t, ".RDS"))

#  gc()
#}

