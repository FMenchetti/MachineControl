##########################################################
##
## Useful Functions
##
## Author: Fiammetta Menchetti
## Last Update: April 2023
##
###########################################################

granger <- function(y, data, p, type = "none", exogen = NULL){
  
  # This function performs bivariate granger causality tests in a multivariate setting
  # (e.g., if 'data' has 3 columns corresponding to A, B and C, it tests if A granger-causes B, if
  # A granger-causes C and if C granger-causes B)
  
  # Param check
  if(!is.character(y)| !y %in% colnames(data)) stop("y must be the name of the response variable")
  # if(!is.character(x)| !x %in% colnames(data)) stop("x must be the name of the cause variable")
  if(any(!class(data) %in% c("matrix", "data.frame"))) stop ("data must be matrix or data.frame")
  if(p != round(p)) stop ("p must be an integer specifying the number of lags")
  
  # Fitting the full model
  fit.full <- VAR(data, p = p, type = type, exogen = exogen)
  
  # Fitting the restricted model
  #ind <- colnames(data) != x
  #fit.restricted <- VAR(data[, ind], p = 2, type = "type", exogen = exogen)
  fit.restricted <- lapply(colnames(data), function(x) VAR(data[,colnames(data) != x], p = p, type = type, exogen = exogen))
  
  # Residual sum of squares
  resid.full <- fit.full$varresult[[y]]$residuals
  rss.full <- sum(resid.full^2)
  # resid.restr <- fit.restricted$varresult[[y]]$residuals
  resid.restr <- lapply(fit.restricted, FUN = function(x) x$varresult[[y]]$residuals)
  # rss.restr <- sum(resid.restr^2)
  rss.restr <- sapply(resid.restr, FUN = function(x) sum(x^2))
  
  # Number of parameters
  n <- dim(data)[1] - p
  p.full <- sum(p*dim(data)[2], dim(exogen)[2])
  p.restr <- sum(p*(dim(data)[2]-1), dim(exogen)[2])
  
  # F statistic
  F_stat <- ((rss.restr-rss.full)/(p.full - p.restr))/(rss.full/(n - p.full))
  F_stat[which(colnames(data) == y)] <- NA
  F_stat
}

#----------------------------------------------------------------------------------------------

granger_multi <- function(data, p, type = "none", exogen = NULL){
  
  # This function creates a matrix of tstatistics by changing the dependent variable along the
  # columns of the provided 'data' matrix
  
  mat_stat <- sapply(colnames(data), FUN = function(y) granger(data, y = y, p = p, type = type, exogen = exogen))
  
  # Returning results
  df.1 <- p 
  df.2 <- dim(data)[1] - p - sum(p*dim(data)[2], dim(exogen)[2])
  res <- list(mat_stat = mat_stat, df.1 = df.1, df.2 = df.2)
  return(res)
}

#------------------------------------------------------------------------------------------------

#' Title
#'
#' @param mat          List, output of a call to granger_multi
#' @param alpha        Significance level
#' @param vertex.names Character vector with the names to be assigned to each vertex in the network graph
#' @param colors       List of two elements, 'list(dt, col)' where 'dt' is a data.frame of two columns.
#'                     The elements in the first column must match 'vertex.names' and the second column is
#'                     contains information on the characteristic of each vertex that should correspond to a different
#'                     color. The second element of the list, 'col' is a vector of colors that must satisfy 
#'                     length(col) == length(unique(dt[,2])) 
#' @param ... 
#'
#'

granger_network_new <- function(mat, alpha = 0.05, vertex.names, size.factor, unidir = TRUE, ...){
  
  # Param checks
  if(class(vertex.names) != "character") stop("'vertex.names' must be character")
  if(length(vertex.names) != dim(mat$mat_stat)[1]) stop ("length(vertex.names) does not match the number of vertex")
  
  # Plotting the network
  mat_stat <- mat$mat_stat
  N <- nrow(mat_stat)
  g <- graph.empty(N, directed = TRUE)
  set.seed(N)
  
  # Set vertex names
  V(g)$name <- vertex.names
  
  # Critical value of the F statistics
  cval <- qf(p = 1-alpha, df1 = mat$df.1, df2 = mat$df.2)
  
  # Loop through each pair of variables and add edges if the test statistic is significant and the reverse is not
  if(unidir){
    for (i in 1:N) {
      for (j in 1:N) {
        if (i != j && abs(mat_stat[i, j]) > cval && abs(mat_stat[j, i]) <= cval) { 
          g <- add_edges(g, c(i, j), weight = mat_stat[i, j])
        }
      }
    }
  } else {
    
    for (i in 1:N) {
      for (j in 1:N) {
        if (i != j && abs(mat_stat[i, j]) >= cval && abs(mat_stat[j, i]) >= cval) { 
          g <- add_edges(g, c(i, j), weight = mat_stat[i, j])
        }
      }
    }
    
  }
  
  
  
  # Set the arrow thickness based on the t-statistic values
  E(g)$width <- abs(E(g)$weight)*size.factor
  
  # Plot the resulting network graph
  layout <- layout_in_circle(g)
  plot(g, layout = layout, vertex.label = V(g)$name, ...)
  
}


granger_network <- function(mat, alpha = 0.05, vertex.names, ...){
  #browser()
  # Given a matrix of tstats created with 'granger_multi', this function uses 
  # iGraph package to plot the resulting network, i.e., if the tstat of the model X --> Y is
  # is significant but Y --> X is not, the function draws a directed arrow otherwise it doesn't
  
  # Plotting the network
  mat_stat <- mat$mat_stat
  N <- nrow(mat_stat)
  g <- graph.empty(N, directed = TRUE)
  set.seed(N)
  
  # Set vertex names
  V(g)$name <- vertex.names
  
  # Critical value of the F statistics
  cval <- qf(p = 1-alpha, df1 = mat$df.1, df2 = mat$df.2)
  
  # Loop through each pair of variables and add edges if the test statistic is significant and the reverse is not
  for (i in 1:N) {
    for (j in 1:N) {
      if (i != j && abs(mat_stat[i, j]) > cval && abs(mat_stat[j, i]) <= cval) { 
        g <- add_edges(g, c(i, j))
      }
    }
  }
  
  # Plot the resulting network graph
  #vertex.size <- max(1, 0.1 * max(nchar(V(g)$name)))
  
  plot(g, vertex.label=V(g)$name, ...)
  #plot(g, vertex.label=V(g)$name, vertex.size = vertex.size, ...)
}

# --------------------------------------------------------------------------------------------

# Custom function per leggere i dati esportati da INGV --> lista di terremoti in tempo reale
# I dati vengono estratti in .txt con separatore "|" ma R non legge tutte le righe
# Trasformandoli in Excel salta per√≤ la formattazione. La funzione seguente ripara manualmente

format_coord <- function(coord){
  
  # Counting number of digits (it should be 5)
  if(sum(coord <= 0)){stop("Coordinates below 0 are not accepted")} else {
    
    ndig <- floor(log10(coord)) + 1
    
  }
  
  # If the number of digits is 5, multiply by 1, otherwise multiply/divide by power of 10
  coord <- round(coord*(10^(5 - ndig)))
  
  # Divide by 1000 (Geographical coordinates are in DD format, eg., 44.155')
  coord <- coord/1000
  coord
}

# -----------------------------------------------------------------------------------------------
true_lag <- function(x, lag = 1){
  
  # x is a vector (not necessarily a ts object). This function shift x 
  # backward of the given number of 'lag' and return a vector of the same length
  # of x
  x_lag <- c(rep(NA, times = lag), head(x, n = length(x)-lag))
  return(x_lag)
}

#----------------------------------------------------------------------------------------------
.xreg.trspl <-
  function(date, nk, degree = 3, demean = FALSE)
  {
    #### Settings
    nobs <- NROW(date)
    #### Extend date up the end of the year
    dateL <- date[nobs]
    eoy   <- as.Date(paste0(format(dateL, "%Y"), "-12-31"))
    date1 <- c(date, seq(from = dateL, to = eoy, by = "day")[-1])
    nobs1 <- NROW(date1)  
    #### x
    x1 <- seq(from = 1/365, by = 1/365, length.out = nobs1)
    #### Equally spaced knots
    by <- (x1[nobs1] - x1[1]) / (nk + 1)
    knots1 <- seq(from = x1[1] + by, by = by, length.out = nk)
    #### Make
    # x1 <- splines::bs(x = x1, knots = knots1, degree = degree)
    x1 <- splines2::naturalSpline(x = x1, knots = knots1, degree = degree)
    colnames(x1) <- paste0("tspl.", 1 : NCOL(x1))
    #### Restore attributes
    attr <- attributes(x1)
    x1 <- x1[1:nobs, , drop = FALSE]
    attr$dim <- dim(x1)
    attributes(x1) <- attr
    #### Demean
    if (demean[1])
    {
      x1 <- x1 - matrix(colMeans(x1), NROW(x1), NCOL(x1), TRUE)
    }
    
    #### Answer
    x1
  }


## Plot function for IRF (NB. UPDATED FUNCTION, COPY ON RLAB AND RE-DRAWS THE IRFs)
# inserire anche un'opzione (se si vuole o meno salvare il grafico)
save_plot_irf <- function(fit, name.from, name.to, wd){
  browser()
  irff <- irf(fit, impulse = name.from, response = name.to, n.ahead = 20, ortho = F)
  #png(paste0(wd, "/Figures/irf_from", name.from, "_to" , name.to, ".png"), width = 600, height = 300)
  ylim <- c(min(irff$Lower[[1]]), max(irff$Upper[[1]]))
  plot(irff$irf[[1]], type = "l", xlab = "Steps ahead", ylab = paste(irff$response), ylim = ylim, main = paste("Impulse Response from", irff$impulse))
  lines(irff$Lower[[1]], lty = 2, col = "red")
  lines(irff$Upper[[1]], lty = 2, col = "red")
  abline(h = 0, col = "red")
  #dev.off()
  
}

