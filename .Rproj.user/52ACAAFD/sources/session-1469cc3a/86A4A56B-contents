#################################################################
##                                                             ##
## GENERIC FUNCTIONS for datasets manipulation                 ##
##                                                             ##
## Author: Fiammetta Menchetti                                 ##
##                                                             ##
## Date last edited : September 2022                           ##
##                                                             ##
##                                                             ##
#################################################################

#################################################################
# Checking the class of columns in a dataset
#################################################################

check_class <- function(data){
  
  # Vector storing the 'class' of each column
  cl <- c()
  for(i in 1:ncol(data)){
    cl <- c(cl, class(data[,i]))
  }
  
  # Indexing columns belonging to each class
  num <- which(cl == "numeric") ; fac <- which(cl == "factor")
  chr <- which(cl == "character") ; int <- which(cl == "integer")
  dat <- which(cl == "Date") ; log <- which(cl == "logical")
  
  # Results
  res_list <- list(numeric = list(num = num, names = colnames(data)[num]), 
                   integer = list(int = int, names = colnames(data)[int]),
                   character = list(chr = chr, names = colnames(data)[chr]), 
                   factor = list(fac = fac, names = colnames(data)[fac]),
                   date = list(dat = dat, names = colnames(data)[dat]), 
                   logical = list(log = log, names = colnames(data)[log]))
  return(res_list)
}

#################################################################
# Checking duplicated columns
#################################################################

check_duplicates <- function(data){
  
  # Empty matrix
  duplicates <- matrix(NA, ncol = ncol(data), nrow = ncol(data))
  
  # Looping on rows and columns
  for(i in 1:ncol(data)){
    for(j in 1:ncol(data)){
      duplicates[i,j] <- identical(data[, i], data[, j])
      # duplicates[i,j] <- all(data[, i] == data[, j], na.rm = T)
    }
  }
  
  # Isolating the indexes of duplicated columns
  duplicates[lower.tri(duplicates, diag = TRUE)] <- NA
  ind <- which(colSums(duplicates, na.rm = TRUE) >= 1)
  
  # Returning results
  return(ind)
}

#################################################################
# Checking NA's
#################################################################

check_NA <- function(data, threshold = 0.5){ 
  
  # How many NA's in each column?
  na <- colSums(is.na(data))
  na.pp <- na/nrow(data)
  na.summary <- c(min = min(na), median = median(na), mean = mean(na), max = max(na))
  
  # Which column has a % of NA higher than 'threshold'?
  ind.na <- which(na.pp >= threshold)
  
  # Returning results
  res_list <- list(na = na, na.pp = na.pp, na.summary = na.summary, ind.na = ind.na)
  
  return(res_list)
}

#################################################################
# Table of descriptive statistics
#################################################################

descriptive_stats <- function(data, col_index = NULL){
  
  # Settings
  if(is.null(col_index)){
    col_index <- 1:ncol(data)
  }
  
  data_new <- data[, col_index]
  
  # Checking class & selecting numeric/integer/logical columns 
  cl <- check_class(data_new)
  num <- cl$numeric$num
  int <- cl$integer$int
  log <- cl$logical$log
  ind <- c(num, int, log)
  
  # Table
  tab <- data.frame(Min = apply(data_new[, ind], 2, min, na.rm = T),
                    Median = apply(data_new[, ind], 2, median, na.rm = T),
                    Mean = apply(data_new[, ind], 2, mean, na.rm = T),
                    Max = apply(data_new[, ind], 2, max, na.rm = T),
                    Sd = apply(data_new[, ind], 2, sd, na.rm = T))
  
  # Return results
  return(tab)
  
}


#################################################################
# Imputation of missing values with the stratified mean
#################################################################

impute_mean <- function(cols, data, strati){ 
  
  # 'data' must be a data.frame
  # 'cols' must be a vector of indexes (numeric or character) of the columns with missingness in 'data')
  # 'strati' must be a vector of indexes (numeric or characters) for the column in data 
  #          we wants to stratify for (e.g., missing values in x are imputed with the mean
  #          value for the units having the same characteristics as 'x'). The cols identified
  #          in 'strati' must be factors.
  
  ### Checks
  if(!is.data.frame(data)) stop("'data' must be a data.frame")
  
  ### looping
  for(x in cols){
    
    # Which are NA's
    nas <- which(is.na(data[, x]))
    
    # Priting
    print(paste("Number of replaced NA in", x, "is", length(nas)))
    
    # Computing the mean of x for each unique combination of 'strati'
    sub <- do.call(expand.grid, apply(data[, strati], 2, unique))
    sub <- apply(sub, 1, as.character)
    mean.vec <- sapply(1:ncol(sub), FUN = function(i){
      ind <- which(apply(data[, strati], 1, function(j) all(j %in% sub[,i])))
      mean(data[ind, x], na.rm = T)
    })
    
    # Assigning the mean to data[nas, ] based on their values in 'strati'
    for(i in nas){
      
      ind <- which(apply(sub, 2, function(x) all(x == data[i, strati])))
      data[i, x] <- mean.vec[ind]
      
    }
    
  }
  
  return(data)
  
}


